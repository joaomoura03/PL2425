Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FUNCTION

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON block DOT
Rule 2     block -> declarations procedures BEGIN statements END
Rule 3     procedures -> procedure_declaration procedures
Rule 4     procedures -> empty
Rule 5     procedure_declaration -> PROCEDURE ID SEMICOLON procedure_block SEMICOLON
Rule 6     procedure_block -> declarations BEGIN statements END
Rule 7     declarations -> VAR var_declaration_list
Rule 8     declarations -> empty
Rule 9     var_declaration_list -> var_declaration SEMICOLON var_declaration_list
Rule 10    var_declaration_list -> var_declaration SEMICOLON
Rule 11    var_declaration -> id_list COLON type
Rule 12    id_list -> ID
Rule 13    id_list -> ID COMMA id_list
Rule 14    array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type
Rule 15    type -> INTEGER
Rule 16    type -> BOOLEAN
Rule 17    type -> STRING
Rule 18    type -> REAL
Rule 19    type -> array_type
Rule 20    statements -> statement SEMICOLON statements
Rule 21    statements -> statement
Rule 22    statement -> assignment
Rule 23    statement -> writeln
Rule 24    statement -> readln
Rule 25    statement -> if_statement
Rule 26    statement -> while_statement
Rule 27    statement -> for_statement
Rule 28    statement -> compound_statement
Rule 29    statement -> procedure_call
Rule 30    statement -> empty
Rule 31    procedure_call -> ID
Rule 32    compound_statement -> BEGIN statements END
Rule 33    assignment -> variable ASSIGN expression
Rule 34    variable -> ID
Rule 35    variable -> ID LBRACKET expression RBRACKET
Rule 36    writeln -> WRITELN LPAREN expression_list RPAREN
Rule 37    expression_list -> expression
Rule 38    expression_list -> expression COMMA expression_list
Rule 39    readln -> READLN LPAREN variable RPAREN
Rule 40    if_statement -> IF expression THEN statement
Rule 41    if_statement -> IF expression THEN statement ELSE statement
Rule 42    while_statement -> WHILE expression DO statement
Rule 43    for_statement -> FOR ID ASSIGN expression TO expression DO statement
Rule 44    for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement
Rule 45    expression -> simple_expression
Rule 46    expression -> simple_expression EQUAL simple_expression
Rule 47    expression -> simple_expression NE simple_expression
Rule 48    expression -> simple_expression LT simple_expression
Rule 49    expression -> simple_expression LE simple_expression
Rule 50    expression -> simple_expression GT simple_expression
Rule 51    expression -> simple_expression GE simple_expression
Rule 52    simple_expression -> term
Rule 53    simple_expression -> simple_expression PLUS term
Rule 54    simple_expression -> simple_expression MINUS term
Rule 55    simple_expression -> simple_expression OR term
Rule 56    term -> factor
Rule 57    term -> term TIMES factor
Rule 58    term -> term DIVIDE factor
Rule 59    term -> term DIV factor
Rule 60    term -> term MOD factor
Rule 61    term -> term AND factor
Rule 62    factor -> variable
Rule 63    factor -> NUMBER
Rule 64    factor -> STRING_LITERAL
Rule 65    factor -> TRUE
Rule 66    factor -> FALSE
Rule 67    factor -> LPAREN expression RPAREN
Rule 68    empty -> <empty>

Terminals, with rules where they appear

AND                  : 61
ARRAY                : 14
ASSIGN               : 33 43 44
BEGIN                : 2 6 32
BOOLEAN              : 16
COLON                : 11
COMMA                : 13 38
DIV                  : 59
DIVIDE               : 58
DO                   : 42 43 44
DOT                  : 1
DOTDOT               : 14
DOWNTO               : 44
ELSE                 : 41
END                  : 2 6 32
EQUAL                : 46
FALSE                : 66
FOR                  : 43 44
FUNCTION             : 
GE                   : 51
GT                   : 50
ID                   : 1 5 12 13 31 34 35 43 44
IF                   : 40 41
INTEGER              : 15
LBRACKET             : 14 35
LE                   : 49
LPAREN               : 36 39 67
LT                   : 48
MINUS                : 54
MOD                  : 60
NE                   : 47
NUMBER               : 14 14 63
OF                   : 14
OR                   : 55
PLUS                 : 53
PROCEDURE            : 5
PROGRAM              : 1
RBRACKET             : 14 35
READLN               : 39
REAL                 : 18
RPAREN               : 36 39 67
SEMICOLON            : 1 5 5 9 10 20
STRING               : 17
STRING_LITERAL       : 64
THEN                 : 40 41
TIMES                : 57
TO                   : 43
TRUE                 : 65
VAR                  : 7
WHILE                : 42
WRITELN              : 36
error                : 

Nonterminals, with rules where they appear

array_type           : 19
assignment           : 22
block                : 1
compound_statement   : 28
declarations         : 2 6
empty                : 4 8 30
expression           : 33 35 37 38 40 41 42 43 43 44 44 67
expression_list      : 36 38
factor               : 56 57 58 59 60 61
for_statement        : 27
id_list              : 11 13
if_statement         : 25
procedure_block      : 5
procedure_call       : 29
procedure_declaration : 3
procedures           : 2 3
program              : 0
readln               : 24
simple_expression    : 45 46 46 47 47 48 48 49 49 50 50 51 51 53 54 55
statement            : 20 21 40 41 41 42 43 44
statements           : 2 6 20 32
term                 : 52 53 54 55 57 58 59 60 61
type                 : 11 14
var_declaration      : 9 10
var_declaration_list : 7 9
variable             : 33 39 62
while_statement      : 26
writeln              : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON block DOT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON block DOT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON block DOT

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . block DOT
    (2) block -> . declarations procedures BEGIN statements END
    (7) declarations -> . VAR var_declaration_list
    (8) declarations -> . empty
    (68) empty -> .

    VAR             shift and go to state 7
    PROCEDURE       reduce using rule 68 (empty -> .)
    BEGIN           reduce using rule 68 (empty -> .)

    block                          shift and go to state 5
    declarations                   shift and go to state 6
    empty                          shift and go to state 8

state 5

    (1) program -> PROGRAM ID SEMICOLON block . DOT

    DOT             shift and go to state 9


state 6

    (2) block -> declarations . procedures BEGIN statements END
    (3) procedures -> . procedure_declaration procedures
    (4) procedures -> . empty
    (5) procedure_declaration -> . PROCEDURE ID SEMICOLON procedure_block SEMICOLON
    (68) empty -> .

    PROCEDURE       shift and go to state 13
    BEGIN           reduce using rule 68 (empty -> .)

    procedures                     shift and go to state 10
    procedure_declaration          shift and go to state 11
    empty                          shift and go to state 12

state 7

    (7) declarations -> VAR . var_declaration_list
    (9) var_declaration_list -> . var_declaration SEMICOLON var_declaration_list
    (10) var_declaration_list -> . var_declaration SEMICOLON
    (11) var_declaration -> . id_list COLON type
    (12) id_list -> . ID
    (13) id_list -> . ID COMMA id_list

    ID              shift and go to state 17

    var_declaration_list           shift and go to state 14
    var_declaration                shift and go to state 15
    id_list                        shift and go to state 16

state 8

    (8) declarations -> empty .

    PROCEDURE       reduce using rule 8 (declarations -> empty .)
    BEGIN           reduce using rule 8 (declarations -> empty .)


state 9

    (1) program -> PROGRAM ID SEMICOLON block DOT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON block DOT .)


state 10

    (2) block -> declarations procedures . BEGIN statements END

    BEGIN           shift and go to state 18


state 11

    (3) procedures -> procedure_declaration . procedures
    (3) procedures -> . procedure_declaration procedures
    (4) procedures -> . empty
    (5) procedure_declaration -> . PROCEDURE ID SEMICOLON procedure_block SEMICOLON
    (68) empty -> .

    PROCEDURE       shift and go to state 13
    BEGIN           reduce using rule 68 (empty -> .)

    procedure_declaration          shift and go to state 11
    procedures                     shift and go to state 19
    empty                          shift and go to state 12

state 12

    (4) procedures -> empty .

    BEGIN           reduce using rule 4 (procedures -> empty .)


state 13

    (5) procedure_declaration -> PROCEDURE . ID SEMICOLON procedure_block SEMICOLON

    ID              shift and go to state 20


state 14

    (7) declarations -> VAR var_declaration_list .

    PROCEDURE       reduce using rule 7 (declarations -> VAR var_declaration_list .)
    BEGIN           reduce using rule 7 (declarations -> VAR var_declaration_list .)


state 15

    (9) var_declaration_list -> var_declaration . SEMICOLON var_declaration_list
    (10) var_declaration_list -> var_declaration . SEMICOLON

    SEMICOLON       shift and go to state 21


state 16

    (11) var_declaration -> id_list . COLON type

    COLON           shift and go to state 22


state 17

    (12) id_list -> ID .
    (13) id_list -> ID . COMMA id_list

    COLON           reduce using rule 12 (id_list -> ID .)
    COMMA           shift and go to state 23


state 18

    (2) block -> declarations procedures BEGIN . statements END
    (20) statements -> . statement SEMICOLON statements
    (21) statements -> . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statements                     shift and go to state 25
    statement                      shift and go to state 26
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 19

    (3) procedures -> procedure_declaration procedures .

    BEGIN           reduce using rule 3 (procedures -> procedure_declaration procedures .)


state 20

    (5) procedure_declaration -> PROCEDURE ID . SEMICOLON procedure_block SEMICOLON

    SEMICOLON       shift and go to state 43


state 21

    (9) var_declaration_list -> var_declaration SEMICOLON . var_declaration_list
    (10) var_declaration_list -> var_declaration SEMICOLON .
    (9) var_declaration_list -> . var_declaration SEMICOLON var_declaration_list
    (10) var_declaration_list -> . var_declaration SEMICOLON
    (11) var_declaration -> . id_list COLON type
    (12) id_list -> . ID
    (13) id_list -> . ID COMMA id_list

    PROCEDURE       reduce using rule 10 (var_declaration_list -> var_declaration SEMICOLON .)
    BEGIN           reduce using rule 10 (var_declaration_list -> var_declaration SEMICOLON .)
    ID              shift and go to state 17

    var_declaration                shift and go to state 15
    var_declaration_list           shift and go to state 44
    id_list                        shift and go to state 16

state 22

    (11) var_declaration -> id_list COLON . type
    (15) type -> . INTEGER
    (16) type -> . BOOLEAN
    (17) type -> . STRING
    (18) type -> . REAL
    (19) type -> . array_type
    (14) array_type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 46
    BOOLEAN         shift and go to state 47
    STRING          shift and go to state 48
    REAL            shift and go to state 49
    ARRAY           shift and go to state 51

    type                           shift and go to state 45
    array_type                     shift and go to state 50

state 23

    (13) id_list -> ID COMMA . id_list
    (12) id_list -> . ID
    (13) id_list -> . ID COMMA id_list

    ID              shift and go to state 17

    id_list                        shift and go to state 52

state 24

    (32) compound_statement -> BEGIN . statements END
    (20) statements -> . statement SEMICOLON statements
    (21) statements -> . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statements                     shift and go to state 53
    statement                      shift and go to state 26
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 25

    (2) block -> declarations procedures BEGIN statements . END

    END             shift and go to state 54


state 26

    (20) statements -> statement . SEMICOLON statements
    (21) statements -> statement .

    SEMICOLON       shift and go to state 55
    END             reduce using rule 21 (statements -> statement .)


state 27

    (22) statement -> assignment .

    SEMICOLON       reduce using rule 22 (statement -> assignment .)
    END             reduce using rule 22 (statement -> assignment .)
    ELSE            reduce using rule 22 (statement -> assignment .)


state 28

    (23) statement -> writeln .

    SEMICOLON       reduce using rule 23 (statement -> writeln .)
    END             reduce using rule 23 (statement -> writeln .)
    ELSE            reduce using rule 23 (statement -> writeln .)


state 29

    (24) statement -> readln .

    SEMICOLON       reduce using rule 24 (statement -> readln .)
    END             reduce using rule 24 (statement -> readln .)
    ELSE            reduce using rule 24 (statement -> readln .)


state 30

    (25) statement -> if_statement .

    SEMICOLON       reduce using rule 25 (statement -> if_statement .)
    END             reduce using rule 25 (statement -> if_statement .)
    ELSE            reduce using rule 25 (statement -> if_statement .)


state 31

    (26) statement -> while_statement .

    SEMICOLON       reduce using rule 26 (statement -> while_statement .)
    END             reduce using rule 26 (statement -> while_statement .)
    ELSE            reduce using rule 26 (statement -> while_statement .)


state 32

    (27) statement -> for_statement .

    SEMICOLON       reduce using rule 27 (statement -> for_statement .)
    END             reduce using rule 27 (statement -> for_statement .)
    ELSE            reduce using rule 27 (statement -> for_statement .)


state 33

    (28) statement -> compound_statement .

    SEMICOLON       reduce using rule 28 (statement -> compound_statement .)
    END             reduce using rule 28 (statement -> compound_statement .)
    ELSE            reduce using rule 28 (statement -> compound_statement .)


state 34

    (29) statement -> procedure_call .

    SEMICOLON       reduce using rule 29 (statement -> procedure_call .)
    END             reduce using rule 29 (statement -> procedure_call .)
    ELSE            reduce using rule 29 (statement -> procedure_call .)


state 35

    (30) statement -> empty .

    SEMICOLON       reduce using rule 30 (statement -> empty .)
    END             reduce using rule 30 (statement -> empty .)
    ELSE            reduce using rule 30 (statement -> empty .)


state 36

    (33) assignment -> variable . ASSIGN expression

    ASSIGN          shift and go to state 56


state 37

    (36) writeln -> WRITELN . LPAREN expression_list RPAREN

    LPAREN          shift and go to state 57


state 38

    (39) readln -> READLN . LPAREN variable RPAREN

    LPAREN          shift and go to state 58


state 39

    (40) if_statement -> IF . expression THEN statement
    (41) if_statement -> IF . expression THEN statement ELSE statement
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 59
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 40

    (42) while_statement -> WHILE . expression DO statement
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 70
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 41

    (43) for_statement -> FOR . ID ASSIGN expression TO expression DO statement
    (44) for_statement -> FOR . ID ASSIGN expression DOWNTO expression DO statement

    ID              shift and go to state 71


state 42

    (31) procedure_call -> ID .
    (34) variable -> ID .
    (35) variable -> ID . LBRACKET expression RBRACKET

    SEMICOLON       reduce using rule 31 (procedure_call -> ID .)
    END             reduce using rule 31 (procedure_call -> ID .)
    ELSE            reduce using rule 31 (procedure_call -> ID .)
    ASSIGN          reduce using rule 34 (variable -> ID .)
    LBRACKET        shift and go to state 72


state 43

    (5) procedure_declaration -> PROCEDURE ID SEMICOLON . procedure_block SEMICOLON
    (6) procedure_block -> . declarations BEGIN statements END
    (7) declarations -> . VAR var_declaration_list
    (8) declarations -> . empty
    (68) empty -> .

    VAR             shift and go to state 7
    BEGIN           reduce using rule 68 (empty -> .)

    procedure_block                shift and go to state 73
    declarations                   shift and go to state 74
    empty                          shift and go to state 8

state 44

    (9) var_declaration_list -> var_declaration SEMICOLON var_declaration_list .

    PROCEDURE       reduce using rule 9 (var_declaration_list -> var_declaration SEMICOLON var_declaration_list .)
    BEGIN           reduce using rule 9 (var_declaration_list -> var_declaration SEMICOLON var_declaration_list .)


state 45

    (11) var_declaration -> id_list COLON type .

    SEMICOLON       reduce using rule 11 (var_declaration -> id_list COLON type .)


state 46

    (15) type -> INTEGER .

    SEMICOLON       reduce using rule 15 (type -> INTEGER .)


state 47

    (16) type -> BOOLEAN .

    SEMICOLON       reduce using rule 16 (type -> BOOLEAN .)


state 48

    (17) type -> STRING .

    SEMICOLON       reduce using rule 17 (type -> STRING .)


state 49

    (18) type -> REAL .

    SEMICOLON       reduce using rule 18 (type -> REAL .)


state 50

    (19) type -> array_type .

    SEMICOLON       reduce using rule 19 (type -> array_type .)


state 51

    (14) array_type -> ARRAY . LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    LBRACKET        shift and go to state 75


state 52

    (13) id_list -> ID COMMA id_list .

    COLON           reduce using rule 13 (id_list -> ID COMMA id_list .)


state 53

    (32) compound_statement -> BEGIN statements . END

    END             shift and go to state 76


state 54

    (2) block -> declarations procedures BEGIN statements END .

    DOT             reduce using rule 2 (block -> declarations procedures BEGIN statements END .)


state 55

    (20) statements -> statement SEMICOLON . statements
    (20) statements -> . statement SEMICOLON statements
    (21) statements -> . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 26
    statements                     shift and go to state 77
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 56

    (33) assignment -> variable ASSIGN . expression
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    variable                       shift and go to state 63
    expression                     shift and go to state 78
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62

state 57

    (36) writeln -> WRITELN LPAREN . expression_list RPAREN
    (37) expression_list -> . expression
    (38) expression_list -> . expression COMMA expression_list
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression_list                shift and go to state 79
    expression                     shift and go to state 80
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 58

    (39) readln -> READLN LPAREN . variable RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    ID              shift and go to state 69

    variable                       shift and go to state 81

state 59

    (40) if_statement -> IF expression . THEN statement
    (41) if_statement -> IF expression . THEN statement ELSE statement

    THEN            shift and go to state 82


state 60

    (45) expression -> simple_expression .
    (46) expression -> simple_expression . EQUAL simple_expression
    (47) expression -> simple_expression . NE simple_expression
    (48) expression -> simple_expression . LT simple_expression
    (49) expression -> simple_expression . LE simple_expression
    (50) expression -> simple_expression . GT simple_expression
    (51) expression -> simple_expression . GE simple_expression
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 45 (expression -> simple_expression .)
    DO              reduce using rule 45 (expression -> simple_expression .)
    SEMICOLON       reduce using rule 45 (expression -> simple_expression .)
    END             reduce using rule 45 (expression -> simple_expression .)
    ELSE            reduce using rule 45 (expression -> simple_expression .)
    COMMA           reduce using rule 45 (expression -> simple_expression .)
    RPAREN          reduce using rule 45 (expression -> simple_expression .)
    RBRACKET        reduce using rule 45 (expression -> simple_expression .)
    TO              reduce using rule 45 (expression -> simple_expression .)
    DOWNTO          reduce using rule 45 (expression -> simple_expression .)
    EQUAL           shift and go to state 83
    NE              shift and go to state 84
    LT              shift and go to state 85
    LE              shift and go to state 86
    GT              shift and go to state 87
    GE              shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 61

    (52) simple_expression -> term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . DIV factor
    (60) term -> term . MOD factor
    (61) term -> term . AND factor

    EQUAL           reduce using rule 52 (simple_expression -> term .)
    NE              reduce using rule 52 (simple_expression -> term .)
    LT              reduce using rule 52 (simple_expression -> term .)
    LE              reduce using rule 52 (simple_expression -> term .)
    GT              reduce using rule 52 (simple_expression -> term .)
    GE              reduce using rule 52 (simple_expression -> term .)
    PLUS            reduce using rule 52 (simple_expression -> term .)
    MINUS           reduce using rule 52 (simple_expression -> term .)
    OR              reduce using rule 52 (simple_expression -> term .)
    THEN            reduce using rule 52 (simple_expression -> term .)
    DO              reduce using rule 52 (simple_expression -> term .)
    SEMICOLON       reduce using rule 52 (simple_expression -> term .)
    END             reduce using rule 52 (simple_expression -> term .)
    ELSE            reduce using rule 52 (simple_expression -> term .)
    COMMA           reduce using rule 52 (simple_expression -> term .)
    RPAREN          reduce using rule 52 (simple_expression -> term .)
    RBRACKET        reduce using rule 52 (simple_expression -> term .)
    TO              reduce using rule 52 (simple_expression -> term .)
    DOWNTO          reduce using rule 52 (simple_expression -> term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    DIV             shift and go to state 94
    MOD             shift and go to state 95
    AND             shift and go to state 96


state 62

    (56) term -> factor .

    TIMES           reduce using rule 56 (term -> factor .)
    DIVIDE          reduce using rule 56 (term -> factor .)
    DIV             reduce using rule 56 (term -> factor .)
    MOD             reduce using rule 56 (term -> factor .)
    AND             reduce using rule 56 (term -> factor .)
    EQUAL           reduce using rule 56 (term -> factor .)
    NE              reduce using rule 56 (term -> factor .)
    LT              reduce using rule 56 (term -> factor .)
    LE              reduce using rule 56 (term -> factor .)
    GT              reduce using rule 56 (term -> factor .)
    GE              reduce using rule 56 (term -> factor .)
    PLUS            reduce using rule 56 (term -> factor .)
    MINUS           reduce using rule 56 (term -> factor .)
    OR              reduce using rule 56 (term -> factor .)
    THEN            reduce using rule 56 (term -> factor .)
    DO              reduce using rule 56 (term -> factor .)
    SEMICOLON       reduce using rule 56 (term -> factor .)
    END             reduce using rule 56 (term -> factor .)
    ELSE            reduce using rule 56 (term -> factor .)
    COMMA           reduce using rule 56 (term -> factor .)
    RPAREN          reduce using rule 56 (term -> factor .)
    RBRACKET        reduce using rule 56 (term -> factor .)
    TO              reduce using rule 56 (term -> factor .)
    DOWNTO          reduce using rule 56 (term -> factor .)


state 63

    (62) factor -> variable .

    TIMES           reduce using rule 62 (factor -> variable .)
    DIVIDE          reduce using rule 62 (factor -> variable .)
    DIV             reduce using rule 62 (factor -> variable .)
    MOD             reduce using rule 62 (factor -> variable .)
    AND             reduce using rule 62 (factor -> variable .)
    EQUAL           reduce using rule 62 (factor -> variable .)
    NE              reduce using rule 62 (factor -> variable .)
    LT              reduce using rule 62 (factor -> variable .)
    LE              reduce using rule 62 (factor -> variable .)
    GT              reduce using rule 62 (factor -> variable .)
    GE              reduce using rule 62 (factor -> variable .)
    PLUS            reduce using rule 62 (factor -> variable .)
    MINUS           reduce using rule 62 (factor -> variable .)
    OR              reduce using rule 62 (factor -> variable .)
    THEN            reduce using rule 62 (factor -> variable .)
    DO              reduce using rule 62 (factor -> variable .)
    SEMICOLON       reduce using rule 62 (factor -> variable .)
    END             reduce using rule 62 (factor -> variable .)
    ELSE            reduce using rule 62 (factor -> variable .)
    COMMA           reduce using rule 62 (factor -> variable .)
    RPAREN          reduce using rule 62 (factor -> variable .)
    RBRACKET        reduce using rule 62 (factor -> variable .)
    TO              reduce using rule 62 (factor -> variable .)
    DOWNTO          reduce using rule 62 (factor -> variable .)


state 64

    (63) factor -> NUMBER .

    TIMES           reduce using rule 63 (factor -> NUMBER .)
    DIVIDE          reduce using rule 63 (factor -> NUMBER .)
    DIV             reduce using rule 63 (factor -> NUMBER .)
    MOD             reduce using rule 63 (factor -> NUMBER .)
    AND             reduce using rule 63 (factor -> NUMBER .)
    EQUAL           reduce using rule 63 (factor -> NUMBER .)
    NE              reduce using rule 63 (factor -> NUMBER .)
    LT              reduce using rule 63 (factor -> NUMBER .)
    LE              reduce using rule 63 (factor -> NUMBER .)
    GT              reduce using rule 63 (factor -> NUMBER .)
    GE              reduce using rule 63 (factor -> NUMBER .)
    PLUS            reduce using rule 63 (factor -> NUMBER .)
    MINUS           reduce using rule 63 (factor -> NUMBER .)
    OR              reduce using rule 63 (factor -> NUMBER .)
    THEN            reduce using rule 63 (factor -> NUMBER .)
    DO              reduce using rule 63 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 63 (factor -> NUMBER .)
    END             reduce using rule 63 (factor -> NUMBER .)
    ELSE            reduce using rule 63 (factor -> NUMBER .)
    COMMA           reduce using rule 63 (factor -> NUMBER .)
    RPAREN          reduce using rule 63 (factor -> NUMBER .)
    RBRACKET        reduce using rule 63 (factor -> NUMBER .)
    TO              reduce using rule 63 (factor -> NUMBER .)
    DOWNTO          reduce using rule 63 (factor -> NUMBER .)


state 65

    (64) factor -> STRING_LITERAL .

    TIMES           reduce using rule 64 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 64 (factor -> STRING_LITERAL .)
    DIV             reduce using rule 64 (factor -> STRING_LITERAL .)
    MOD             reduce using rule 64 (factor -> STRING_LITERAL .)
    AND             reduce using rule 64 (factor -> STRING_LITERAL .)
    EQUAL           reduce using rule 64 (factor -> STRING_LITERAL .)
    NE              reduce using rule 64 (factor -> STRING_LITERAL .)
    LT              reduce using rule 64 (factor -> STRING_LITERAL .)
    LE              reduce using rule 64 (factor -> STRING_LITERAL .)
    GT              reduce using rule 64 (factor -> STRING_LITERAL .)
    GE              reduce using rule 64 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 64 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 64 (factor -> STRING_LITERAL .)
    OR              reduce using rule 64 (factor -> STRING_LITERAL .)
    THEN            reduce using rule 64 (factor -> STRING_LITERAL .)
    DO              reduce using rule 64 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 64 (factor -> STRING_LITERAL .)
    END             reduce using rule 64 (factor -> STRING_LITERAL .)
    ELSE            reduce using rule 64 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 64 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 64 (factor -> STRING_LITERAL .)
    RBRACKET        reduce using rule 64 (factor -> STRING_LITERAL .)
    TO              reduce using rule 64 (factor -> STRING_LITERAL .)
    DOWNTO          reduce using rule 64 (factor -> STRING_LITERAL .)


state 66

    (65) factor -> TRUE .

    TIMES           reduce using rule 65 (factor -> TRUE .)
    DIVIDE          reduce using rule 65 (factor -> TRUE .)
    DIV             reduce using rule 65 (factor -> TRUE .)
    MOD             reduce using rule 65 (factor -> TRUE .)
    AND             reduce using rule 65 (factor -> TRUE .)
    EQUAL           reduce using rule 65 (factor -> TRUE .)
    NE              reduce using rule 65 (factor -> TRUE .)
    LT              reduce using rule 65 (factor -> TRUE .)
    LE              reduce using rule 65 (factor -> TRUE .)
    GT              reduce using rule 65 (factor -> TRUE .)
    GE              reduce using rule 65 (factor -> TRUE .)
    PLUS            reduce using rule 65 (factor -> TRUE .)
    MINUS           reduce using rule 65 (factor -> TRUE .)
    OR              reduce using rule 65 (factor -> TRUE .)
    THEN            reduce using rule 65 (factor -> TRUE .)
    DO              reduce using rule 65 (factor -> TRUE .)
    SEMICOLON       reduce using rule 65 (factor -> TRUE .)
    END             reduce using rule 65 (factor -> TRUE .)
    ELSE            reduce using rule 65 (factor -> TRUE .)
    COMMA           reduce using rule 65 (factor -> TRUE .)
    RPAREN          reduce using rule 65 (factor -> TRUE .)
    RBRACKET        reduce using rule 65 (factor -> TRUE .)
    TO              reduce using rule 65 (factor -> TRUE .)
    DOWNTO          reduce using rule 65 (factor -> TRUE .)


state 67

    (66) factor -> FALSE .

    TIMES           reduce using rule 66 (factor -> FALSE .)
    DIVIDE          reduce using rule 66 (factor -> FALSE .)
    DIV             reduce using rule 66 (factor -> FALSE .)
    MOD             reduce using rule 66 (factor -> FALSE .)
    AND             reduce using rule 66 (factor -> FALSE .)
    EQUAL           reduce using rule 66 (factor -> FALSE .)
    NE              reduce using rule 66 (factor -> FALSE .)
    LT              reduce using rule 66 (factor -> FALSE .)
    LE              reduce using rule 66 (factor -> FALSE .)
    GT              reduce using rule 66 (factor -> FALSE .)
    GE              reduce using rule 66 (factor -> FALSE .)
    PLUS            reduce using rule 66 (factor -> FALSE .)
    MINUS           reduce using rule 66 (factor -> FALSE .)
    OR              reduce using rule 66 (factor -> FALSE .)
    THEN            reduce using rule 66 (factor -> FALSE .)
    DO              reduce using rule 66 (factor -> FALSE .)
    SEMICOLON       reduce using rule 66 (factor -> FALSE .)
    END             reduce using rule 66 (factor -> FALSE .)
    ELSE            reduce using rule 66 (factor -> FALSE .)
    COMMA           reduce using rule 66 (factor -> FALSE .)
    RPAREN          reduce using rule 66 (factor -> FALSE .)
    RBRACKET        reduce using rule 66 (factor -> FALSE .)
    TO              reduce using rule 66 (factor -> FALSE .)
    DOWNTO          reduce using rule 66 (factor -> FALSE .)


state 68

    (67) factor -> LPAREN . expression RPAREN
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 97
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 69

    (34) variable -> ID .
    (35) variable -> ID . LBRACKET expression RBRACKET

    TIMES           reduce using rule 34 (variable -> ID .)
    DIVIDE          reduce using rule 34 (variable -> ID .)
    DIV             reduce using rule 34 (variable -> ID .)
    MOD             reduce using rule 34 (variable -> ID .)
    AND             reduce using rule 34 (variable -> ID .)
    EQUAL           reduce using rule 34 (variable -> ID .)
    NE              reduce using rule 34 (variable -> ID .)
    LT              reduce using rule 34 (variable -> ID .)
    LE              reduce using rule 34 (variable -> ID .)
    GT              reduce using rule 34 (variable -> ID .)
    GE              reduce using rule 34 (variable -> ID .)
    PLUS            reduce using rule 34 (variable -> ID .)
    MINUS           reduce using rule 34 (variable -> ID .)
    OR              reduce using rule 34 (variable -> ID .)
    THEN            reduce using rule 34 (variable -> ID .)
    DO              reduce using rule 34 (variable -> ID .)
    SEMICOLON       reduce using rule 34 (variable -> ID .)
    END             reduce using rule 34 (variable -> ID .)
    ELSE            reduce using rule 34 (variable -> ID .)
    COMMA           reduce using rule 34 (variable -> ID .)
    RPAREN          reduce using rule 34 (variable -> ID .)
    RBRACKET        reduce using rule 34 (variable -> ID .)
    TO              reduce using rule 34 (variable -> ID .)
    DOWNTO          reduce using rule 34 (variable -> ID .)
    LBRACKET        shift and go to state 72


state 70

    (42) while_statement -> WHILE expression . DO statement

    DO              shift and go to state 98


state 71

    (43) for_statement -> FOR ID . ASSIGN expression TO expression DO statement
    (44) for_statement -> FOR ID . ASSIGN expression DOWNTO expression DO statement

    ASSIGN          shift and go to state 99


state 72

    (35) variable -> ID LBRACKET . expression RBRACKET
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 100
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 73

    (5) procedure_declaration -> PROCEDURE ID SEMICOLON procedure_block . SEMICOLON

    SEMICOLON       shift and go to state 101


state 74

    (6) procedure_block -> declarations . BEGIN statements END

    BEGIN           shift and go to state 102


state 75

    (14) array_type -> ARRAY LBRACKET . NUMBER DOTDOT NUMBER RBRACKET OF type

    NUMBER          shift and go to state 103


state 76

    (32) compound_statement -> BEGIN statements END .

    SEMICOLON       reduce using rule 32 (compound_statement -> BEGIN statements END .)
    END             reduce using rule 32 (compound_statement -> BEGIN statements END .)
    ELSE            reduce using rule 32 (compound_statement -> BEGIN statements END .)


state 77

    (20) statements -> statement SEMICOLON statements .

    END             reduce using rule 20 (statements -> statement SEMICOLON statements .)


state 78

    (33) assignment -> variable ASSIGN expression .

    SEMICOLON       reduce using rule 33 (assignment -> variable ASSIGN expression .)
    END             reduce using rule 33 (assignment -> variable ASSIGN expression .)
    ELSE            reduce using rule 33 (assignment -> variable ASSIGN expression .)


state 79

    (36) writeln -> WRITELN LPAREN expression_list . RPAREN

    RPAREN          shift and go to state 104


state 80

    (37) expression_list -> expression .
    (38) expression_list -> expression . COMMA expression_list

    RPAREN          reduce using rule 37 (expression_list -> expression .)
    COMMA           shift and go to state 105


state 81

    (39) readln -> READLN LPAREN variable . RPAREN

    RPAREN          shift and go to state 106


state 82

    (40) if_statement -> IF expression THEN . statement
    (41) if_statement -> IF expression THEN . statement ELSE statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    ELSE            reduce using rule 68 (empty -> .)
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 107
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 83

    (46) expression -> simple_expression EQUAL . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 108
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 84

    (47) expression -> simple_expression NE . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 109
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 85

    (48) expression -> simple_expression LT . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 110
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 86

    (49) expression -> simple_expression LE . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 111
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 87

    (50) expression -> simple_expression GT . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 112
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 88

    (51) expression -> simple_expression GE . simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    simple_expression              shift and go to state 113
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 89

    (53) simple_expression -> simple_expression PLUS . term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    term                           shift and go to state 114
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 90

    (54) simple_expression -> simple_expression MINUS . term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    term                           shift and go to state 115
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 91

    (55) simple_expression -> simple_expression OR . term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    term                           shift and go to state 116
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 92

    (57) term -> term TIMES . factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    factor                         shift and go to state 117
    variable                       shift and go to state 63

state 93

    (58) term -> term DIVIDE . factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    factor                         shift and go to state 118
    variable                       shift and go to state 63

state 94

    (59) term -> term DIV . factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    factor                         shift and go to state 119
    variable                       shift and go to state 63

state 95

    (60) term -> term MOD . factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    factor                         shift and go to state 120
    variable                       shift and go to state 63

state 96

    (61) term -> term AND . factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    factor                         shift and go to state 121
    variable                       shift and go to state 63

state 97

    (67) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 122


state 98

    (42) while_statement -> WHILE expression DO . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    ELSE            reduce using rule 68 (empty -> .)
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 123
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 99

    (43) for_statement -> FOR ID ASSIGN . expression TO expression DO statement
    (44) for_statement -> FOR ID ASSIGN . expression DOWNTO expression DO statement
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 124
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 100

    (35) variable -> ID LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 125


state 101

    (5) procedure_declaration -> PROCEDURE ID SEMICOLON procedure_block SEMICOLON .

    PROCEDURE       reduce using rule 5 (procedure_declaration -> PROCEDURE ID SEMICOLON procedure_block SEMICOLON .)
    BEGIN           reduce using rule 5 (procedure_declaration -> PROCEDURE ID SEMICOLON procedure_block SEMICOLON .)


state 102

    (6) procedure_block -> declarations BEGIN . statements END
    (20) statements -> . statement SEMICOLON statements
    (21) statements -> . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statements                     shift and go to state 126
    statement                      shift and go to state 26
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 103

    (14) array_type -> ARRAY LBRACKET NUMBER . DOTDOT NUMBER RBRACKET OF type

    DOTDOT          shift and go to state 127


state 104

    (36) writeln -> WRITELN LPAREN expression_list RPAREN .

    SEMICOLON       reduce using rule 36 (writeln -> WRITELN LPAREN expression_list RPAREN .)
    END             reduce using rule 36 (writeln -> WRITELN LPAREN expression_list RPAREN .)
    ELSE            reduce using rule 36 (writeln -> WRITELN LPAREN expression_list RPAREN .)


state 105

    (38) expression_list -> expression COMMA . expression_list
    (37) expression_list -> . expression
    (38) expression_list -> . expression COMMA expression_list
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 80
    expression_list                shift and go to state 128
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 106

    (39) readln -> READLN LPAREN variable RPAREN .

    SEMICOLON       reduce using rule 39 (readln -> READLN LPAREN variable RPAREN .)
    END             reduce using rule 39 (readln -> READLN LPAREN variable RPAREN .)
    ELSE            reduce using rule 39 (readln -> READLN LPAREN variable RPAREN .)


state 107

    (40) if_statement -> IF expression THEN statement .
    (41) if_statement -> IF expression THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 40 (if_statement -> IF expression THEN statement .)
    END             reduce using rule 40 (if_statement -> IF expression THEN statement .)
    ELSE            shift and go to state 129

  ! ELSE            [ reduce using rule 40 (if_statement -> IF expression THEN statement .) ]


state 108

    (46) expression -> simple_expression EQUAL simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    DO              reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    SEMICOLON       reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    END             reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    ELSE            reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    COMMA           reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    RPAREN          reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    RBRACKET        reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    TO              reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    DOWNTO          reduce using rule 46 (expression -> simple_expression EQUAL simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 109

    (47) expression -> simple_expression NE simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    DO              reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    SEMICOLON       reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    END             reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    ELSE            reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    COMMA           reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    RPAREN          reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    RBRACKET        reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    TO              reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    DOWNTO          reduce using rule 47 (expression -> simple_expression NE simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 110

    (48) expression -> simple_expression LT simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    DO              reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    SEMICOLON       reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    END             reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    ELSE            reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    COMMA           reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    RPAREN          reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    RBRACKET        reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    TO              reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    DOWNTO          reduce using rule 48 (expression -> simple_expression LT simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 111

    (49) expression -> simple_expression LE simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    DO              reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    SEMICOLON       reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    END             reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    ELSE            reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    COMMA           reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    RPAREN          reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    RBRACKET        reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    TO              reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    DOWNTO          reduce using rule 49 (expression -> simple_expression LE simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 112

    (50) expression -> simple_expression GT simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    DO              reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    SEMICOLON       reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    END             reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    ELSE            reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    COMMA           reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    RPAREN          reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    RBRACKET        reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    TO              reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    DOWNTO          reduce using rule 50 (expression -> simple_expression GT simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 113

    (51) expression -> simple_expression GE simple_expression .
    (53) simple_expression -> simple_expression . PLUS term
    (54) simple_expression -> simple_expression . MINUS term
    (55) simple_expression -> simple_expression . OR term

    THEN            reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    DO              reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    SEMICOLON       reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    END             reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    ELSE            reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    COMMA           reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    RPAREN          reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    RBRACKET        reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    TO              reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    DOWNTO          reduce using rule 51 (expression -> simple_expression GE simple_expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    OR              shift and go to state 91


state 114

    (53) simple_expression -> simple_expression PLUS term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . DIV factor
    (60) term -> term . MOD factor
    (61) term -> term . AND factor

    EQUAL           reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    NE              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    LT              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    LE              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    GT              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    GE              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    PLUS            reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    MINUS           reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    OR              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    THEN            reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    DO              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    SEMICOLON       reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    END             reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    ELSE            reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    COMMA           reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    RPAREN          reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    RBRACKET        reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    TO              reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    DOWNTO          reduce using rule 53 (simple_expression -> simple_expression PLUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    DIV             shift and go to state 94
    MOD             shift and go to state 95
    AND             shift and go to state 96


state 115

    (54) simple_expression -> simple_expression MINUS term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . DIV factor
    (60) term -> term . MOD factor
    (61) term -> term . AND factor

    EQUAL           reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    NE              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    LT              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    LE              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    GT              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    GE              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    PLUS            reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    MINUS           reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    OR              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    THEN            reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    DO              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    SEMICOLON       reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    END             reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    ELSE            reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    COMMA           reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    RPAREN          reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    RBRACKET        reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    TO              reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    DOWNTO          reduce using rule 54 (simple_expression -> simple_expression MINUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    DIV             shift and go to state 94
    MOD             shift and go to state 95
    AND             shift and go to state 96


state 116

    (55) simple_expression -> simple_expression OR term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . DIV factor
    (60) term -> term . MOD factor
    (61) term -> term . AND factor

    EQUAL           reduce using rule 55 (simple_expression -> simple_expression OR term .)
    NE              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    LT              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    LE              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    GT              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    GE              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    PLUS            reduce using rule 55 (simple_expression -> simple_expression OR term .)
    MINUS           reduce using rule 55 (simple_expression -> simple_expression OR term .)
    OR              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    THEN            reduce using rule 55 (simple_expression -> simple_expression OR term .)
    DO              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    SEMICOLON       reduce using rule 55 (simple_expression -> simple_expression OR term .)
    END             reduce using rule 55 (simple_expression -> simple_expression OR term .)
    ELSE            reduce using rule 55 (simple_expression -> simple_expression OR term .)
    COMMA           reduce using rule 55 (simple_expression -> simple_expression OR term .)
    RPAREN          reduce using rule 55 (simple_expression -> simple_expression OR term .)
    RBRACKET        reduce using rule 55 (simple_expression -> simple_expression OR term .)
    TO              reduce using rule 55 (simple_expression -> simple_expression OR term .)
    DOWNTO          reduce using rule 55 (simple_expression -> simple_expression OR term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    DIV             shift and go to state 94
    MOD             shift and go to state 95
    AND             shift and go to state 96


state 117

    (57) term -> term TIMES factor .

    TIMES           reduce using rule 57 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 57 (term -> term TIMES factor .)
    DIV             reduce using rule 57 (term -> term TIMES factor .)
    MOD             reduce using rule 57 (term -> term TIMES factor .)
    AND             reduce using rule 57 (term -> term TIMES factor .)
    EQUAL           reduce using rule 57 (term -> term TIMES factor .)
    NE              reduce using rule 57 (term -> term TIMES factor .)
    LT              reduce using rule 57 (term -> term TIMES factor .)
    LE              reduce using rule 57 (term -> term TIMES factor .)
    GT              reduce using rule 57 (term -> term TIMES factor .)
    GE              reduce using rule 57 (term -> term TIMES factor .)
    PLUS            reduce using rule 57 (term -> term TIMES factor .)
    MINUS           reduce using rule 57 (term -> term TIMES factor .)
    OR              reduce using rule 57 (term -> term TIMES factor .)
    THEN            reduce using rule 57 (term -> term TIMES factor .)
    DO              reduce using rule 57 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 57 (term -> term TIMES factor .)
    END             reduce using rule 57 (term -> term TIMES factor .)
    ELSE            reduce using rule 57 (term -> term TIMES factor .)
    COMMA           reduce using rule 57 (term -> term TIMES factor .)
    RPAREN          reduce using rule 57 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 57 (term -> term TIMES factor .)
    TO              reduce using rule 57 (term -> term TIMES factor .)
    DOWNTO          reduce using rule 57 (term -> term TIMES factor .)


state 118

    (58) term -> term DIVIDE factor .

    TIMES           reduce using rule 58 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 58 (term -> term DIVIDE factor .)
    DIV             reduce using rule 58 (term -> term DIVIDE factor .)
    MOD             reduce using rule 58 (term -> term DIVIDE factor .)
    AND             reduce using rule 58 (term -> term DIVIDE factor .)
    EQUAL           reduce using rule 58 (term -> term DIVIDE factor .)
    NE              reduce using rule 58 (term -> term DIVIDE factor .)
    LT              reduce using rule 58 (term -> term DIVIDE factor .)
    LE              reduce using rule 58 (term -> term DIVIDE factor .)
    GT              reduce using rule 58 (term -> term DIVIDE factor .)
    GE              reduce using rule 58 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 58 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 58 (term -> term DIVIDE factor .)
    OR              reduce using rule 58 (term -> term DIVIDE factor .)
    THEN            reduce using rule 58 (term -> term DIVIDE factor .)
    DO              reduce using rule 58 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 58 (term -> term DIVIDE factor .)
    END             reduce using rule 58 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 58 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 58 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 58 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 58 (term -> term DIVIDE factor .)
    TO              reduce using rule 58 (term -> term DIVIDE factor .)
    DOWNTO          reduce using rule 58 (term -> term DIVIDE factor .)


state 119

    (59) term -> term DIV factor .

    TIMES           reduce using rule 59 (term -> term DIV factor .)
    DIVIDE          reduce using rule 59 (term -> term DIV factor .)
    DIV             reduce using rule 59 (term -> term DIV factor .)
    MOD             reduce using rule 59 (term -> term DIV factor .)
    AND             reduce using rule 59 (term -> term DIV factor .)
    EQUAL           reduce using rule 59 (term -> term DIV factor .)
    NE              reduce using rule 59 (term -> term DIV factor .)
    LT              reduce using rule 59 (term -> term DIV factor .)
    LE              reduce using rule 59 (term -> term DIV factor .)
    GT              reduce using rule 59 (term -> term DIV factor .)
    GE              reduce using rule 59 (term -> term DIV factor .)
    PLUS            reduce using rule 59 (term -> term DIV factor .)
    MINUS           reduce using rule 59 (term -> term DIV factor .)
    OR              reduce using rule 59 (term -> term DIV factor .)
    THEN            reduce using rule 59 (term -> term DIV factor .)
    DO              reduce using rule 59 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 59 (term -> term DIV factor .)
    END             reduce using rule 59 (term -> term DIV factor .)
    ELSE            reduce using rule 59 (term -> term DIV factor .)
    COMMA           reduce using rule 59 (term -> term DIV factor .)
    RPAREN          reduce using rule 59 (term -> term DIV factor .)
    RBRACKET        reduce using rule 59 (term -> term DIV factor .)
    TO              reduce using rule 59 (term -> term DIV factor .)
    DOWNTO          reduce using rule 59 (term -> term DIV factor .)


state 120

    (60) term -> term MOD factor .

    TIMES           reduce using rule 60 (term -> term MOD factor .)
    DIVIDE          reduce using rule 60 (term -> term MOD factor .)
    DIV             reduce using rule 60 (term -> term MOD factor .)
    MOD             reduce using rule 60 (term -> term MOD factor .)
    AND             reduce using rule 60 (term -> term MOD factor .)
    EQUAL           reduce using rule 60 (term -> term MOD factor .)
    NE              reduce using rule 60 (term -> term MOD factor .)
    LT              reduce using rule 60 (term -> term MOD factor .)
    LE              reduce using rule 60 (term -> term MOD factor .)
    GT              reduce using rule 60 (term -> term MOD factor .)
    GE              reduce using rule 60 (term -> term MOD factor .)
    PLUS            reduce using rule 60 (term -> term MOD factor .)
    MINUS           reduce using rule 60 (term -> term MOD factor .)
    OR              reduce using rule 60 (term -> term MOD factor .)
    THEN            reduce using rule 60 (term -> term MOD factor .)
    DO              reduce using rule 60 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 60 (term -> term MOD factor .)
    END             reduce using rule 60 (term -> term MOD factor .)
    ELSE            reduce using rule 60 (term -> term MOD factor .)
    COMMA           reduce using rule 60 (term -> term MOD factor .)
    RPAREN          reduce using rule 60 (term -> term MOD factor .)
    RBRACKET        reduce using rule 60 (term -> term MOD factor .)
    TO              reduce using rule 60 (term -> term MOD factor .)
    DOWNTO          reduce using rule 60 (term -> term MOD factor .)


state 121

    (61) term -> term AND factor .

    TIMES           reduce using rule 61 (term -> term AND factor .)
    DIVIDE          reduce using rule 61 (term -> term AND factor .)
    DIV             reduce using rule 61 (term -> term AND factor .)
    MOD             reduce using rule 61 (term -> term AND factor .)
    AND             reduce using rule 61 (term -> term AND factor .)
    EQUAL           reduce using rule 61 (term -> term AND factor .)
    NE              reduce using rule 61 (term -> term AND factor .)
    LT              reduce using rule 61 (term -> term AND factor .)
    LE              reduce using rule 61 (term -> term AND factor .)
    GT              reduce using rule 61 (term -> term AND factor .)
    GE              reduce using rule 61 (term -> term AND factor .)
    PLUS            reduce using rule 61 (term -> term AND factor .)
    MINUS           reduce using rule 61 (term -> term AND factor .)
    OR              reduce using rule 61 (term -> term AND factor .)
    THEN            reduce using rule 61 (term -> term AND factor .)
    DO              reduce using rule 61 (term -> term AND factor .)
    SEMICOLON       reduce using rule 61 (term -> term AND factor .)
    END             reduce using rule 61 (term -> term AND factor .)
    ELSE            reduce using rule 61 (term -> term AND factor .)
    COMMA           reduce using rule 61 (term -> term AND factor .)
    RPAREN          reduce using rule 61 (term -> term AND factor .)
    RBRACKET        reduce using rule 61 (term -> term AND factor .)
    TO              reduce using rule 61 (term -> term AND factor .)
    DOWNTO          reduce using rule 61 (term -> term AND factor .)


state 122

    (67) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    MOD             reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    TO              reduce using rule 67 (factor -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 67 (factor -> LPAREN expression RPAREN .)


state 123

    (42) while_statement -> WHILE expression DO statement .

    SEMICOLON       reduce using rule 42 (while_statement -> WHILE expression DO statement .)
    END             reduce using rule 42 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 42 (while_statement -> WHILE expression DO statement .)


state 124

    (43) for_statement -> FOR ID ASSIGN expression . TO expression DO statement
    (44) for_statement -> FOR ID ASSIGN expression . DOWNTO expression DO statement

    TO              shift and go to state 130
    DOWNTO          shift and go to state 131


state 125

    (35) variable -> ID LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DIV             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    MOD             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    AND             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    EQUAL           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    NE              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    LT              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    GT              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    THEN            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DO              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    END             reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    TO              reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 35 (variable -> ID LBRACKET expression RBRACKET .)


state 126

    (6) procedure_block -> declarations BEGIN statements . END

    END             shift and go to state 132


state 127

    (14) array_type -> ARRAY LBRACKET NUMBER DOTDOT . NUMBER RBRACKET OF type

    NUMBER          shift and go to state 133


state 128

    (38) expression_list -> expression COMMA expression_list .

    RPAREN          reduce using rule 38 (expression_list -> expression COMMA expression_list .)


state 129

    (41) if_statement -> IF expression THEN statement ELSE . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    ELSE            reduce using rule 68 (empty -> .)
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 134
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 130

    (43) for_statement -> FOR ID ASSIGN expression TO . expression DO statement
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 135
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 131

    (44) for_statement -> FOR ID ASSIGN expression DOWNTO . expression DO statement
    (45) expression -> . simple_expression
    (46) expression -> . simple_expression EQUAL simple_expression
    (47) expression -> . simple_expression NE simple_expression
    (48) expression -> . simple_expression LT simple_expression
    (49) expression -> . simple_expression LE simple_expression
    (50) expression -> . simple_expression GT simple_expression
    (51) expression -> . simple_expression GE simple_expression
    (52) simple_expression -> . term
    (53) simple_expression -> . simple_expression PLUS term
    (54) simple_expression -> . simple_expression MINUS term
    (55) simple_expression -> . simple_expression OR term
    (56) term -> . factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term DIV factor
    (60) term -> . term MOD factor
    (61) term -> . term AND factor
    (62) factor -> . variable
    (63) factor -> . NUMBER
    (64) factor -> . STRING_LITERAL
    (65) factor -> . TRUE
    (66) factor -> . FALSE
    (67) factor -> . LPAREN expression RPAREN
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    NUMBER          shift and go to state 64
    STRING_LITERAL  shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    LPAREN          shift and go to state 68
    ID              shift and go to state 69

    expression                     shift and go to state 136
    simple_expression              shift and go to state 60
    term                           shift and go to state 61
    factor                         shift and go to state 62
    variable                       shift and go to state 63

state 132

    (6) procedure_block -> declarations BEGIN statements END .

    SEMICOLON       reduce using rule 6 (procedure_block -> declarations BEGIN statements END .)


state 133

    (14) array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER . RBRACKET OF type

    RBRACKET        shift and go to state 137


state 134

    (41) if_statement -> IF expression THEN statement ELSE statement .

    SEMICOLON       reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    END             reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)


state 135

    (43) for_statement -> FOR ID ASSIGN expression TO expression . DO statement

    DO              shift and go to state 138


state 136

    (44) for_statement -> FOR ID ASSIGN expression DOWNTO expression . DO statement

    DO              shift and go to state 139


state 137

    (14) array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET . OF type

    OF              shift and go to state 140


state 138

    (43) for_statement -> FOR ID ASSIGN expression TO expression DO . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    ELSE            reduce using rule 68 (empty -> .)
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 141
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 139

    (44) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO . statement
    (22) statement -> . assignment
    (23) statement -> . writeln
    (24) statement -> . readln
    (25) statement -> . if_statement
    (26) statement -> . while_statement
    (27) statement -> . for_statement
    (28) statement -> . compound_statement
    (29) statement -> . procedure_call
    (30) statement -> . empty
    (33) assignment -> . variable ASSIGN expression
    (36) writeln -> . WRITELN LPAREN expression_list RPAREN
    (39) readln -> . READLN LPAREN variable RPAREN
    (40) if_statement -> . IF expression THEN statement
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) while_statement -> . WHILE expression DO statement
    (43) for_statement -> . FOR ID ASSIGN expression TO expression DO statement
    (44) for_statement -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (32) compound_statement -> . BEGIN statements END
    (31) procedure_call -> . ID
    (68) empty -> .
    (34) variable -> . ID
    (35) variable -> . ID LBRACKET expression RBRACKET

    WRITELN         shift and go to state 37
    READLN          shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    BEGIN           shift and go to state 24
    ID              shift and go to state 42
    ELSE            reduce using rule 68 (empty -> .)
    SEMICOLON       reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    statement                      shift and go to state 142
    assignment                     shift and go to state 27
    writeln                        shift and go to state 28
    readln                         shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    for_statement                  shift and go to state 32
    compound_statement             shift and go to state 33
    procedure_call                 shift and go to state 34
    empty                          shift and go to state 35
    variable                       shift and go to state 36

state 140

    (14) array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF . type
    (15) type -> . INTEGER
    (16) type -> . BOOLEAN
    (17) type -> . STRING
    (18) type -> . REAL
    (19) type -> . array_type
    (14) array_type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 46
    BOOLEAN         shift and go to state 47
    STRING          shift and go to state 48
    REAL            shift and go to state 49
    ARRAY           shift and go to state 51

    type                           shift and go to state 143
    array_type                     shift and go to state 50

state 141

    (43) for_statement -> FOR ID ASSIGN expression TO expression DO statement .

    SEMICOLON       reduce using rule 43 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    END             reduce using rule 43 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)
    ELSE            reduce using rule 43 (for_statement -> FOR ID ASSIGN expression TO expression DO statement .)


state 142

    (44) for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .

    SEMICOLON       reduce using rule 44 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    END             reduce using rule 44 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    ELSE            reduce using rule 44 (for_statement -> FOR ID ASSIGN expression DOWNTO expression DO statement .)


state 143

    (14) array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .

    SEMICOLON       reduce using rule 14 (array_type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 107 resolved as shift
